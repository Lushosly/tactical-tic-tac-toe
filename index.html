<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Conquest</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Exo+2:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050b14;
            --grid: #0d1b2a;
            --text: #e0e1dd;
            --player: #00f5d4;
            --cpu: #ff0055;
            --asteroid: #9d4edd;
            --warn: #fee440;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            background-color: var(--bg);
            background-image: 
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 3px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 2px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 3px);
            background-size: 550px 550px, 350px 350px, 250px 250px;
            background-position: 0 0, 40px 60px, 130px 270px;
            color: var(--text);
            font-family: 'Exo 2', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        /* LANGUAGE TOGGLE */
        .lang-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        .lang-btn {
            background: rgba(13, 27, 42, 0.8);
            border: 1px solid var(--player);
            color: var(--text);
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            border-radius: 4px;
        }
        .lang-btn.active { background: var(--player); color: #000; }

        h1 { 
            color: var(--player); 
            margin-bottom: 5px; 
            font-family: 'Orbitron', sans-serif; 
            text-shadow: 0 0 10px rgba(0, 245, 212, 0.5);
            letter-spacing: 2px;
            text-align: center;
            margin-top: 40px;
        }
        p { margin-bottom: 25px; font-size: 0.9rem; color: #8892b0; letter-spacing: 1px; text-align: center; }

        .game-container {
            display: flex;
            flex-wrap: wrap;
            gap: 2.5rem;
            justify-content: center;
            align-items: flex-start;
        }

        /* BOARD */
        .board {
            display: grid;
            grid-template-columns: repeat(4, 75px);
            grid-template-rows: repeat(4, 75px);
            gap: 12px;
            background: rgba(13, 27, 42, 0.8);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #1b263b;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        .cell {
            background: #1b263b;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        .cell:hover { background: #415a77; box-shadow: 0 0 10px var(--player); }
        .cell.p1 { text-shadow: 0 0 10px var(--player); animation: popIn 0.3s; }
        .cell.cpu { text-shadow: 0 0 10px var(--cpu); animation: popIn 0.3s; }
        .cell.block { text-shadow: 0 0 10px var(--asteroid); }
        
        .cell.hazmat {
            background: rgba(255, 0, 85, 0.15);
            border: 1px dashed var(--cpu);
            cursor: not-allowed;
        }
        .cell.hazmat::after {
            content: '‚ò¢';
            font-size: 0.8rem;
            position: absolute;
            top: 2px;
            right: 2px;
            color: var(--cpu);
        }

        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* CONTROLS */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 280px;
        }

        .status {
            background: rgba(13, 27, 42, 0.9);
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid var(--player);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }

        .powers {
            display: grid;
            gap: 12px;
        }

        .btn {
            padding: 14px;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            letter-spacing: 1px;
            transition: all 0.2s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }
        .btn:active { transform: scale(0.98); }
        
        .btn-bomb { background: linear-gradient(45deg, #ff0055, #a4133c); color: #fff; }
        .btn-override { background: linear-gradient(45deg, #7209b7, #3a0ca3); color: #fff; }
        .btn-block { background: linear-gradient(45deg, #4361ee, #3f37c9); color: #fff; }
        
        .btn-help {
            background: transparent;
            border: 1px solid #415a77;
            color: #778da9;
            margin-top: 10px;
        }
        .btn-help:hover { border-color: var(--player); color: var(--player); }

        .btn-reset { 
            background: transparent; 
            border: 1px solid var(--player); 
            color: var(--player); 
            margin-top: 5px; 
            box-shadow: 0 0 10px rgba(0, 245, 212, 0.1);
        }
        .btn-reset:hover { background: rgba(0, 245, 212, 0.1); }

        .btn:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(100%); }
        .btn.active { box-shadow: 0 0 15px currentColor; border: 1px solid #fff; }

        .log {
            margin-top: 10px;
            font-family: 'Fira Code', monospace;
            font-size: 0.75rem;
            color: #8892b0;
            height: 120px;
            overflow-y: auto;
            border-top: 1px solid #1b263b;
            padding-top: 10px;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 4px;
        }

        /* MODAL STYLES */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 11, 20, 0.95);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 20px;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: #0d1b2a;
            padding: 30px;
            border-radius: 8px;
            border: 1px solid var(--player);
            max-width: 500px;
            width: 100%;
            color: var(--text);
            line-height: 1.6;
            box-shadow: 0 0 30px rgba(0, 245, 212, 0.15);
        }
        .modal h2 { color: var(--player); margin-bottom: 15px; font-family: 'Orbitron', sans-serif; }
        .modal ul { padding-left: 20px; margin-bottom: 25px; list-style-type: none; }
        .modal li { margin-bottom: 12px; }
        .close-btn {
            background: var(--player); color: #050b14;
            padding: 12px 20px; border: none; border-radius: 4px;
            font-weight: bold; cursor: pointer; width: 100%;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
        }
        
        .brain-status {
            margin-top: 5px;
            font-size: 0.65rem;
            color: #8892b0;
            text-align: right;
            border-top: 1px solid #333;
            padding-top: 5px;
        }

        @media (max-width: 600px) {
            .board { grid-template-columns: repeat(4, 60px); grid-template-rows: repeat(4, 60px); }
            .cell { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

    <div class="lang-switch">
        <button class="lang-btn active" onclick="setLang('en')">EN</button>
        <button class="lang-btn" onclick="setLang('es')">ES</button>
    </div>

    <h1 id="title">GALACTIC CONQUEST</h1>
    <p id="subtitle">Secure Sector 4 ‚Ä¢ Align 4 Ships to Win</p>

    <div class="game-container">
        <div class="board" id="board">
            <!-- Cells generated by JS -->
        </div>

        <div class="controls">
            <div class="status" id="status">AWAITING COMMANDS...</div>

            <div class="powers">
                <button class="btn btn-bomb" id="btn-bomb" onclick="selectPower('BOMB')">üí• ORBITAL STRIKE</button>
                <button class="btn btn-override" id="btn-override" onclick="selectPower('OVERRIDE')">üëΩ MIND CONTROL</button>
                <button class="btn btn-block" id="btn-block" onclick="selectPower('BLOCK')">‚òÑÔ∏è ASTEROID</button>
            </div>

            <div class="log">
                <div id="gameLog">
                    > System initialized...<br>
                    > Good luck, Commander.
                </div>
                <div class="brain-status" id="ai-mem-status">AI MEMORY: 0 PATTERNS</div>
            </div>

            <button class="btn btn-help" id="btn-help" onclick="openModal()">[?] TACTICAL BRIEFING</button>
            <button class="btn btn-reset" id="btn-reset" onclick="resetGame()">REBOOT SYSTEM</button>
        </div>
    </div>

    <!-- HELP MODAL -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">TACTICAL BRIEFING</h2>
            <p id="modal-obj"><strong>MISSION:</strong> Align 4 Starships (üöÄ) horizontally, vertically, or diagonally to secure the sector.</p>
            <hr style="border: 0; border-top: 1px solid #1b263b; margin: 15px 0;">
            <p><strong id="modal-arsenal">ARSENAL (One-time use):</strong></p>
            <ul>
                <li id="desc-bomb">üí• <strong>ORBITAL STRIKE:</strong> Destroys any unit. The blast zone creates radiation (unplayable) for 1 turn.</li>
                <li id="desc-hack">üëΩ <strong>MIND CONTROL:</strong> Hacks an enemy Asteroid (‚òÑÔ∏è) and converts it into your fleet.</li>
                <li id="desc-asteroid">‚òÑÔ∏è <strong>ASTEROID:</strong> Deploys a permanent blockade that no fleet can traverse.</li>
            </ul>
            <button class="close-btn" id="btn-close" onclick="closeModal()">AFFIRMATIVE</button>
        </div>
    </div>

<script>
    // --- LOCALIZATION (I18N) ---
    const I18N = {
        'en': {
            title: "GALACTIC CONQUEST",
            subtitle: "Secure Sector 4 ‚Ä¢ Align 4 Ships to Win",
            statusWait: "AWAITING COMMANDS...",
            statusIncoming: "INCOMING TRANSMISSION...",
            statusWin: " WINS!",
            statusDraw: "STALEMATE DETECTED",
            p1Name: "COMMANDER",
            cpuName: "ALIEN FLEET",
            btnBomb: "üí• ORBITAL STRIKE",
            btnHack: "üëΩ MIND CONTROL",
            btnBlock: "‚òÑÔ∏è ASTEROID",
            btnHelp: "[?] TACTICAL BRIEFING",
            btnReset: "REBOOT SYSTEM",
            logInit: "> System initialized...",
            logLuck: "> Good luck, Commander.",
            logWeaponDepleted: "‚ö†Ô∏è Weapon depleted!",
            logCancel: "Targeting cancelled.",
            logTarget: "üéØ Select coordinates for",
            logInvalid: "‚ùå Invalid Coordinates! Sector occupied or radiated.",
            logStrike: "ordered ORBITAL STRIKE on Sec-",
            logHack: "HACKED the asteroid at Sec-",
            logHackFail: "‚ùå Mind Control only works on Asteroids (‚òÑÔ∏è)",
            logBlock: "dropped an ASTEROID on Sec-",
            logEndWin: "MISSION END: WINS!",
            logEndDraw: "MISSION END: STALEMATE",
            logAIThink: "analyzing outcomes...",
            logAIMemory: "THE ALIEN RECALLED PATTERN!",
            modalTitle: "TACTICAL BRIEFING",
            modalObj: "<strong>MISSION:</strong> Align 4 Starships (üöÄ) horizontally, vertically, or diagonally.",
            modalArsenal: "ARSENAL (One-time use):",
            descBomb: "üí• <strong>ORBITAL STRIKE:</strong> Destroys any unit. Creates Radiation (unplayable) for 1 turn.",
            descHack: "üëΩ <strong>MIND CONTROL:</strong> Hacks an enemy Asteroid (‚òÑÔ∏è) and converts it to your fleet.",
            descAsteroid: "‚òÑÔ∏è <strong>ASTEROID:</strong> Deploys a permanent blockade (#).",
            btnClose: "AFFIRMATIVE"
        },
        'es': {
            title: "CONQUISTA GAL√ÅCTICA",
            subtitle: "Asegura el Sector 4 ‚Ä¢ Alinea 4 Naves para Ganar",
            statusWait: "ESPERANDO ORDENES...",
            statusIncoming: "TRANSMISI√ìN ENTRANTE...",
            statusWin: " ¬°VICTORIA!",
            statusDraw: "EMPATE DETECTADO",
            p1Name: "COMANDANTE",
            cpuName: "FLOTA ALIEN√çGENA",
            btnBomb: "üí• ATAQUE ORBITAL",
            btnHack: "üëΩ CONTROL MENTAL",
            btnBlock: "‚òÑÔ∏è ASTEROIDE",
            btnHelp: "[?] INFORME T√ÅCTICO",
            btnReset: "REINICIAR SISTEMA",
            logInit: "> Sistema inicializado...",
            logLuck: "> Buena suerte, Comandante.",
            logWeaponDepleted: "‚ö†Ô∏è ¬°Arma agotada!",
            logCancel: "Objetivo cancelado.",
            logTarget: "üéØ Seleccione coordenadas para",
            logInvalid: "‚ùå ¬°Coordenadas Inv√°lidas! Sector ocupado o radiado.",
            logStrike: "orden√≥ ATAQUE ORBITAL en Sec-",
            logHack: "HACKE√ì el asteroide en Sec-",
            logHackFail: "‚ùå Control Mental solo funciona en Asteroides (‚òÑÔ∏è)",
            logBlock: "lanz√≥ un ASTEROIDE en Sec-",
            logEndWin: "FIN DE MISI√ìN: ¬°VICTORIA!",
            logEndDraw: "FIN DE MISI√ìN: EMPATE",
            logAIThink: "analizando resultados...",
            logAIMemory: "¬°EL ALIEN RECONOCI√ì PATR√ìN!",
            modalTitle: "INFORME T√ÅCTICO",
            modalObj: "<strong>MISI√ìN:</strong> Alinea 4 Naves (üöÄ) horizontal, vertical o diagonalmente.",
            modalArsenal: "ARSENAL (Un solo uso):",
            descBomb: "üí• <strong>ATAQUE ORBITAL:</strong> Destruye cualquier unidad. Crea Radiaci√≥n (bloqueo) por 1 turno.",
            descHack: "üëΩ <strong>CONTROL MENTAL:</strong> Hackea un Asteroide (‚òÑÔ∏è) enemigo y lo convierte a tu flota.",
            descAsteroid: "‚òÑÔ∏è <strong>ASTEROIDE:</strong> Despliega un bloqueo permanente (#).",
            btnClose: "AFIRMATIVO"
        }
    };

    let curLang = 'en';

    function setLang(lang) {
        curLang = lang;
        document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');

        const t = I18N[lang];
        document.getElementById('title').innerText = t.title;
        document.getElementById('subtitle').innerText = t.subtitle;
        document.getElementById('btn-bomb').innerText = t.btnBomb;
        document.getElementById('btn-override').innerText = t.btnHack;
        document.getElementById('btn-block').innerText = t.btnBlock;
        document.getElementById('btn-help').innerText = t.btnHelp;
        document.getElementById('btn-reset').innerText = t.btnReset;
        
        document.getElementById('modal-title').innerText = t.modalTitle;
        document.getElementById('modal-obj').innerHTML = t.modalObj;
        document.getElementById('modal-arsenal').innerText = t.modalArsenal;
        document.getElementById('desc-bomb').innerHTML = t.descBomb;
        document.getElementById('desc-hack').innerHTML = t.descHack;
        document.getElementById('desc-asteroid').innerHTML = t.descAsteroid;
        document.getElementById('btn-close').innerText = t.btnClose;

        resetGame();
    }

    // === GAME STATE & AI BRAIN ===
    const SYMBOLS = { 'P1': 'üöÄ', 'CPU': 'üõ∏', 'BLOCK': '‚òÑÔ∏è' };
    let board = Array(16).fill(null);
    let hazmat = {}; 
    let currentPlayer = 'P1';
    let gameActive = true;
    let selectedPower = null;
    let powers = {
        'P1': { 'BOMB': true, 'OVERRIDE': true, 'BLOCK': true },
        'CPU': { 'BOMB': true, 'OVERRIDE': true, 'BLOCK': true }
    };
    
    // Q-LEARNING MEMORY
    let aiMemory = JSON.parse(localStorage.getItem('galactic_brain')) || {};
    let matchHistory = []; // Stores {state, move} pairs for current game

    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('gameLog');

    function init() {
        boardEl.innerHTML = '';
        for (let i = 0; i < 16; i++) {
            let cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.index = i;
            cell.onclick = () => handleCellClick(i);
            boardEl.appendChild(cell);
        }
        updateUI();
        updateMemoryStatus();
    }

    function log(msg) {
        logEl.innerHTML = `> ${msg}<br>` + logEl.innerHTML;
    }

    function updateMemoryStatus() {
        document.getElementById('ai-mem-status').innerText = `AI MEMORY: ${Object.keys(aiMemory).length} PATTERNS`;
    }

    function openModal() { document.getElementById('helpModal').style.display = 'flex'; }
    function closeModal() { document.getElementById('helpModal').style.display = 'none'; }

    function selectPower(power) {
        if (!gameActive || currentPlayer !== 'P1') return;
        const t = I18N[curLang];
        
        if (!powers['P1'][power]) {
            log(t.logWeaponDepleted);
            return;
        }

        if (selectedPower === power) {
            selectedPower = null; 
            log(t.logCancel);
        } else {
            selectedPower = power;
            let pName = (power === 'BOMB') ? t.btnBomb : (power === 'OVERRIDE') ? t.btnHack : t.btnBlock;
            log(`${t.logTarget} ${pName}...`);
        }
        updateUI();
    }

    function handleCellClick(index) {
        if (!gameActive || currentPlayer !== 'P1') return;
        const t = I18N[curLang];

        if (selectedPower) {
            executePower('P1', selectedPower, index);
            return;
        }

        if (isValidMove(index, 'P1')) {
            makeMove(index, 'P1');
            if (gameActive) {
                setTimeout(aiTurn, 800);
            }
        } else {
            log(t.logInvalid);
        }
    }

    function executePower(player, power, index) {
        let success = false;
        const t = I18N[curLang];
        let pName = player === 'P1' ? t.p1Name : t.cpuName;

        if (power === 'BOMB') {
            board[index] = null;
            hazmat[index] = { owner: player, turns: 3 }; 
            log(`üí• ${pName} ${t.logStrike}${index+1}!`);
            success = true;
        } 
        else if (power === 'OVERRIDE') {
            if (board[index] === SYMBOLS.BLOCK) {
                board[index] = SYMBOLS[player];
                log(`üëΩ ${pName} ${t.logHack}${index+1}!`);
                success = true;
            } else {
                if(player === 'P1') log(t.logHackFail);
            }
        }
        else if (power === 'BLOCK') {
            if (isValidMove(index, player)) {
                board[index] = SYMBOLS.BLOCK;
                log(`‚òÑÔ∏è ${pName} ${t.logBlock}${index+1}!`);
                success = true;
            } else {
                if(player === 'P1') log(t.logInvalid);
            }
        }

        if (success) {
            powers[player][power] = false;
            selectedPower = null;
            
            // Record Move for AI Learning
            if (player === 'CPU') {
                recordAiMove(getBoardState(), `${power}:${index}`);
            }

            if(checkWin(player)) return;
            if (gameActive) {
                switchTurns();
                if (currentPlayer === 'CPU') setTimeout(aiTurn, 800);
            }
        }
        updateUI();
    }

    function isValidMove(index, player) {
        if (index < 0 || index > 15) return false;
        if (hazmat[index]) {
            if (hazmat[index].owner !== player) return false;
        }
        return board[index] === null;
    }

    function makeMove(index, player) {
        // Record Move for AI Learning
        if (player === 'CPU') {
            recordAiMove(getBoardState(), index);
        }

        board[index] = SYMBOLS[player];
        if (hazmat[index]) delete hazmat[index];
        updateUI();

        setTimeout(() => {
            if (checkWin(player)) return;
            if (!board.includes(null)) {
                endGame(I18N[curLang].statusDraw, 'DRAW');
                return;
            }
            if(gameActive) switchTurns();
        }, 50);
    }

    function switchTurns() {
        currentPlayer = currentPlayer === 'P1' ? 'CPU' : 'P1';
        for (let k in hazmat) {
            hazmat[k].turns--;
            if (hazmat[k].turns <= 0) delete hazmat[k];
        }
        updateUI();
    }

    // === AI BRAIN (Q-Learning) ===
    function getBoardState() {
        return board.join(''); // Simple string key
    }

    function recordAiMove(state, move) {
        matchHistory.push({ state, move });
    }

    function learnFromMatch(result) {
        let reward = 0;
        if (result === 'WIN') reward = 3;    // AI Won
        if (result === 'LOSS') reward = -2;  // AI Lost
        if (result === 'DRAW') reward = 1;   // Draw

        matchHistory.forEach(entry => {
            const { state, move } = entry;
            if (!aiMemory[state]) aiMemory[state] = {};
            if (!aiMemory[state][move]) aiMemory[state][move] = 0;
            
            // Update weight
            aiMemory[state][move] += reward;
        });

        // Save to browser
        localStorage.setItem('galactic_brain', JSON.stringify(aiMemory));
        updateMemoryStatus();
        matchHistory = []; // Reset
    }

    function aiTurn() {
        if (!gameActive) return;
        const t = I18N[curLang];
        statusEl.innerText = t.statusIncoming;
        statusEl.style.color = "#ff0055";

        const state = getBoardState();
        
        // 1. MEMORY CHECK (Exploit)
        // 70% chance to use memory if available
        if (Math.random() < 0.7 && aiMemory[state]) {
            const moves = aiMemory[state];
            // Find best move with positive score
            let bestMove = null;
            let maxScore = -999;
            
            for (let m in moves) {
                if (moves[m] > maxScore) {
                    maxScore = moves[m];
                    bestMove = m;
                }
            }

            if (bestMove && maxScore > 0) {
                // Parse move type
                log(t.logAIMemory);
                if (bestMove.includes(':')) {
                    const [pwr, idx] = bestMove.split(':');
                    if (powers['CPU'][pwr]) {
                        executePower('CPU', pwr, parseInt(idx));
                        return;
                    }
                } else {
                    const idx = parseInt(bestMove);
                    if (isValidMove(idx, 'CPU')) {
                        makeMove(idx, 'CPU');
                        return;
                    }
                }
            }
        }

        // 2. HEURISTICS (Explore)
        // If no memory or exploring, use standard logic
        let winMove = findWinningMove('CPU');
        if (winMove !== -1) { makeMove(winMove, 'CPU'); return; }

        let blockMove = findWinningMove('P1');
        if (blockMove !== -1) {
            if (powers['CPU']['BOMB'] && Math.random() < 0.3) {
                executePower('CPU', 'BOMB', blockMove);
                return;
            }
            makeMove(blockMove, 'CPU');
            return;
        }

        if (Math.random() < 0.2 && powers['CPU']['BLOCK']) {
            let empties = getEmptyIndices();
            if(empties.length > 0) {
                executePower('CPU', 'BLOCK', empties[Math.floor(Math.random() * empties.length)]);
                return;
            }
        }

        let empties = getEmptyIndices();
        if(empties.length > 0) {
            let move = empties[Math.floor(Math.random() * empties.length)];
            makeMove(move, 'CPU');
        }
    }

    function findWinningMove(playerKey) {
        let empties = getEmptyIndices();
        let sym = SYMBOLS[playerKey];
        for (let i of empties) {
            board[i] = sym;
            if (checkWinCondition(sym)) {
                board[i] = null; return i;
            }
            board[i] = null;
        }
        return -1;
    }

    function getEmptyIndices() {
        let indices = [];
        for(let i=0; i<16; i++) {
            if (isValidMove(i, 'CPU')) indices.push(i);
        }
        return indices;
    }

    function checkWin(playerKey) {
        if (checkWinCondition(SYMBOLS[playerKey])) {
            const t = I18N[curLang];
            let winnerName = playerKey === 'P1' ? t.p1Name : t.cpuName;
            
            // Determine result for Learning
            let result = playerKey === 'CPU' ? 'WIN' : 'LOSS';
            endGame(`${winnerName} ${t.statusWin}`, result);
            return true;
        }
        return false;
    }

    function checkWinCondition(s) {
        const wins = [
            [0,1,2,3], [4,5,6,7], [8,9,10,11], [12,13,14,15], 
            [0,4,8,12], [1,5,9,13], [2,6,10,14], [3,7,11,15], 
            [0,5,10,15], [3,6,9,12] 
        ];
        return wins.some(combo => combo.every(i => board[i] === s));
    }

    function endGame(msg, result) {
        gameActive = false;
        statusEl.innerText = msg;
        statusEl.style.color = msg.includes(I18N[curLang].p1Name) ? "#00f5d4" : "#ff0055";
        log(`üèÅ ${msg}`);
        
        // Trigger Learning
        learnFromMatch(result);
    }

    function resetGame() {
        const t = I18N[curLang];
        board = Array(16).fill(null);
        hazmat = {};
        currentPlayer = 'P1';
        gameActive = true;
        selectedPower = null;
        powers = {
            'P1': { 'BOMB': true, 'OVERRIDE': true, 'BLOCK': true },
            'CPU': { 'BOMB': true, 'OVERRIDE': true, 'BLOCK': true }
        };
        logEl.innerHTML = `${t.logInit}<br>${t.logLuck}`;
        statusEl.style.color = "inherit";
        matchHistory = []; // Reset history for new game
        init();
    }

    function updateUI() {
        const t = I18N[curLang];
        const cells = document.querySelectorAll('.cell');
        cells.forEach((cell, i) => {
            cell.className = 'cell'; 
            if (board[i] === SYMBOLS.P1) cell.classList.add('p1');
            if (board[i] === SYMBOLS.CPU) cell.classList.add('cpu');
            if (board[i] === SYMBOLS.BLOCK) cell.classList.add('block');
            if (hazmat[i]) cell.classList.add('hazmat');
            cell.innerText = board[i] || '';
        });

        if (gameActive) {
            statusEl.innerText = currentPlayer === 'P1' ? t.statusWait : t.statusIncoming;
            statusEl.style.color = currentPlayer === 'P1' ? "#00f5d4" : "#ff0055";
        }
        
        const bombBtn = document.getElementById('btn-bomb');
        const overrideBtn = document.getElementById('btn-override');
        const blockBtn = document.getElementById('btn-block');

        if(bombBtn) {
            bombBtn.disabled = !powers['P1']['BOMB'];
            bombBtn.innerText = t.btnBomb;
            bombBtn.classList.toggle('active', selectedPower === 'BOMB');
        }
        if(overrideBtn) {
            overrideBtn.disabled = !powers['P1']['OVERRIDE'];
            overrideBtn.innerText = t.btnHack;
            overrideBtn.classList.toggle('active', selectedPower === 'OVERRIDE');
        }
        if(blockBtn) {
            blockBtn.disabled = !powers['P1']['BLOCK'];
            blockBtn.innerText = t.btnBlock;
            blockBtn.classList.toggle('active', selectedPower === 'BLOCK');
        }
    }

    // START
    init();

</script>
</body>
</html>
